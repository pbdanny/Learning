'AIC=', model$aic, ' SSE=', sse,' p-VALUE=', pval$p.value,'\n')
d <- data.frame('p' = p-1, 'd' = d, 'q' = q-1, 'P' = i-1, 'D' = DD, 'Q' = j-1, 'S' = per,
'AIC' = model$aic, 'SSE' = sse, 'pval' = pval$p.value)
df <- rbind(df, d)
}
}
}
}
}
d <- 1  # non seasonal difference
DD <- 1  # seasonal difference
per <- 12  # S = 12
df <- NULL
for(p in 1:1){
for(q in 1:1){
for(i in 1:3){
for(j in 1:4){
if(p+d+q+i+DD+j <= 10){
model <- arima(x = Milk, order = c((p-1), d, (q-1)),
seasonal = list(order = c((i-1), DD, (j-1)),
period = per))
pval <- Box.test(model$residuals, lag = log(length(model$residuals)))
sse <- sum(model$residuals^2)
cat(p-1,d,q-1,i-1,DD,j-1,per,
'AIC=', model$aic, ' SSE=', sse,' p-VALUE=', pval$p.value,'\n')
m <- data.frame('p' = p-1, 'd' = d, 'q' = q-1, 'P' = i-1, 'D' = DD, 'Q' = j-1, 'S' = per,
'AIC' = model$aic, 'SSE' = sse, 'pval' = pval$p.value)
df <- rbind(df, m)
}
}
}
}
}
df
df(sort(df$AIC, decreasing = T))
df[sort(df$AIC, decreasing = T),]
df[,sort(df$AIC, decreasing = T)]
df
df[sort(df$AIC, decreasing = T)]
df[sort(df$AIC, decreasing = T),]
str(df)
df[sort(df$AIC, decreasing = T),]
str(df)
df[order(df$AIC, decreasing = T),]
df[order(AIC, decreasing = T),]
df[order(df$AIC, df$SSE, decreasing = c(T, T)),]
df[order(df$AIC, df$SSE, decreasing = c(F, T)),]
# order by min aic, min SSE
df[order(df$AIC, df$SSE),]
# create best model
model<- arima(x = Milk, order = c(0, 1, 0),
seasonal = list(order = c(0, 1, 1), period = 12))
library(forecast)
plot(forecast(model))
forecast(model)
dev.off()
plot(forecast(model))
forecast(model)
SUV <- read.csv('./Documents/Learning/Coursera/R Practical Time Series Analysis-SUNY/monthly-sales-for-a-souvenir-sho.csv',
stringsAsFactors = FALSE)
SUV
str(SUV)
colnames(SUV) <- c('month', 'Sales')
suv <- ts(SUV$Sales)
library(astsa)
par(mfrow=c(2,2))
plot(suv, main='Monthly sales for a souvenir shop', ylab='', col='blue', lwd=3)
plot(log(suv), main='Log-transorm of sales', ylab='', col='red', lwd=3)
SUV[-nrow(SUV),]
suv <- ts(SUV$Sales)
par(mfrow=c(2,2))
plot(suv, main='Monthly sales for a souvenir shop', ylab='', col='blue', lwd=3)
SUV <- read.csv('./Documents/Learning/Coursera/R Practical Time Series Analysis-SUNY/monthly-sales-for-a-souvenir-sho.csv',
stringsAsFactors = FALSE)
colnames(SUV) <- c('month', 'Sales')
SUV[-nrow(SUV),]
suv <- ts(SUV$Sales)
SUV <- read.csv('./Documents/Learning/Coursera/R Practical Time Series Analysis-SUNY/monthly-sales-for-a-souvenir-sho.csv',
stringsAsFactors = FALSE)
tail(SUV)
View(SUV)
SUV[-nrow(SUV),]
View(SUV)
SUV <- SUV[-nrow(SUV),]
suv <- ts(SUV$Sales)
SUV <- read.csv('./Documents/Learning/Coursera/R Practical Time Series Analysis-SUNY/monthly-sales-for-a-souvenir-sho.csv',
stringsAsFactors = FALSE)
colnames(SUV) <- c('month', 'Sales')
SUV <- SUV[-nrow(SUV),]
suv <- ts(SUV$Sales)
library(astsa)
par(mfrow=c(2,2))
plot(suv, main='Monthly sales for a souvenir shop', ylab='', col='blue', lwd=3)
plot(log(suv), main='Log-transorm of sales', ylab='', col='red', lwd=3)
str(suv)
str(SUV)
suv <- ts(as.numeric(SUV$Sales))
library(astsa)
par(mfrow=c(2,2))
plot(suv, main='Monthly sales for a souvenir shop', ylab='', col='blue', lwd=3)
plot(log(suv), main='Log-transorm of sales', ylab='', col='red', lwd=3)
plot(diff(log(suv)), main='Differenced Log-transorm of sales', ylab='', col='brown', lwd=3)
plot(diff(diff(log(suv)),12), main='Log-transorm without trend and seasonaliy', ylab='', col='green', lwd=3)
par(mfrow=c(2,2))
plot(suv, main='Monthly sales for a souvenir shop', ylab='', col='blue', lwd=3)
plot(log(suv), main='Log-transorm of sales', ylab='', col='red', lwd=3)
plot(diff(log(suv)), main='Differenced Log-transorm of sales', ylab='', col='brown', lwd=3)
plot(diff(diff(log(suv)),12), main='Log-transorm without trend and seasonaliy', ylab='', col='green', lwd=3)
data<-diff(diff((log(suv)),12))
acf2(data, 50)
d <- 1
DD <- 1
per <- 12
for(p in 1:2){
for(q in 1:2){
for(i in 1:2){
for(j in 1:4){
if(p+d+q+i+DD+j<=10){
model<-arima(x=log(suv), order = c((p-1),d,(q-1)), seasonal = list(order=c((i-1),DD,(j-1)), period=per))
pval<-Box.test(model$residuals, lag=log(length(model$residuals)))
sse<-sum(model$residuals^2)
cat(p-1,d,q-1,i-1,DD,j-1,per, 'AIC=', model$aic, ' SSE=',sse,' p-VALUE=', pval$p.value,'\n')
}
}
}
}
}
model<- arima(x=log(suv), order = c(1,1,0), seasonal = list(order=c(0,1,1), period=12))
library(forecast)
plot(forecast(model))
forecast(model)
dev.off()
plot(forecast(model))
forecast(model)
a<-sarima.for(log(suv),12,1,1,0,0,1,1,12)
plot.ts(c(suv,exp(a$pred)), main='Monthly sales + Forecast', ylab='', col='blue', lwd=3)
a<-sarima.for(log(suv),12,1,1,0,0,1,1,12)
t <- diff(diff(USAccDeaths), 12)
# obtain acf and pacf below
acf(t)
pacf(t)
## Quiz SARIMA ----
par(mfrow=c(2,1))
t <- diff(diff(USAccDeaths), 12)
# obtain acf and pacf below
acf(t)
pacf(t)
# obtain acf and pacf below
acf(t, lag.max = 50)
pacf(t, lag.max = 50)
## Quiz SARIMA ----
par(mfrow=c(2,1))
# obtain acf and pacf below
acf(t, lag.max = 30)
pacf(t, lag.max = 30)
acData <- diff(diff(USAccDeaths, 12))
# obtain acf and pacf below
acf(acData, lag.max = 30)
pacf(acData, lag.max = 30)
sarima(x = USAccDeaths, 0,1,1,0,1,1, 12)
sarima(USAccDeaths, 0,1,1,0,1,1, 12)
install.packages(c("bindrcpp", "broom", "caret", "curl", "FactoMineR", "lava", "lme4", "mapproj", "plogr", "randomForest", "rgdal", "selectr", "sf", "spData", "viridis"))
## Quiz SARIMA ----
par(mfrow=c(2,1))
acData <- diff(diff(USAccDeaths, 12))
# obtain acf and pacf below
acf(acData, lag.max = 30)
pacf(acData, lag.max = 30)
## Quiz SARIMA ----
par(mfrow=c(2,2))
acData <- diff(diff(USAccDeaths, 12))
# obtain acf and pacf below
acf(acData, lag.max = 30, main = 'diff-12, diff')
pacf(acData, lag.max = 30, main = 'diff-12, diff')
acf(diff(diff(USAccDeaths), 12), lag.max = 30, main = 'diff, diff-12')
pacf(diff(diff(USAccDeaths), 12), lag.max = 30, main = 'diff, diff-12')
dev.off()
sarima(USAccDeaths, 0,1,1,0,1,1, 12)
library(astsa)
sarima(USAccDeaths, 0,1,1,0,1,1, 12)
.552*.4303
model <- sarima(USAccDeaths, 0,1,1,0,1,1, 12)
model$ttable
?sarima
sarima.for(USAccDeaths, 0,1,1,0,1,1, 12)
sarima.for(model)
?arima.for
?sarima.for
sarima.for(USAccDeaths,n.ahead = 12 , 0,1,1,0,1,1, 12)
rain.data <- scan("http://robjhyndman.com/tsdldata/hurst/precip1.dat", skip = 1)
rain.ts <- ts(rain.data, start=c(1813))
plot(rain.ts)
# histogram plot
par( mfrow=c(1,2) )
hist(rain.data, main = "Annual London Rainfall 1813-1912",
xlab = "rainfall in inches")
qqnorm(rain.data,main="Normal Plot of London Rainfall")
qqline(rain.data)
# histogram plot
par( mfrow=c(1,2) )
hist(rain.data, main = "Annual London Rainfall 1813-1912",
xlab = "rainfall in inches")
qqnorm(rain.data,main="Normal Plot of London Rainfall")
qqline(rain.data, col = 'red')
# time plot
par(mfrow = c(2, 1))
plot.ts(rain.ts, main="Annual London Rainfall 1813-1912",
xlab="year", ylab="rainfall in inches")
acf(rain.ts, main="ACF: London Rainfall")
# check if auto.corr.coef exist
library(forecast)
auto.arima(rain.ts)
install.packages("TSA")
install.packages(c("bindrcpp", "caret", "mapproj"))
## Simple Exponentail Smoothing ----
rm(list = ls())
getwe()
getwd()
setwd('/Users/Danny/Documents/Learning/Coursera/R Practical Time Series Analysis-SUNY')
money <- read.csv(file = 'volume-of-money-abs-definition-m.csv', stringsAsFactors = F)
View(money)
money_ts <- ts(money[,2])
money_ts <- money[-length(money),]
View(money_ts)
money_ts <- ts(money[,2])
View(money_ts)
money_ts <- money_ts[-length(money_ts),]
money <- money[-length(money),]
money_ts <- ts(money[,2])
View(money_ts)
tail(money_ts)
money <- read.csv(file = 'volume-of-money-abs-definition-m.csv', stringsAsFactors = F)
money <- money[-length(money),]
View(money)
money <- read.csv(file = 'volume-of-money-abs-definition-m.csv', stringsAsFactors = F)
nrow(money)
money <- money[-length(money), ]
nrow(money)
Viw(money)
View(money)
money <- read.csv(file = 'volume-of-money-abs-definition-m.csv', stringsAsFactors = F)
View(money)
money <- money[-419, ]
View(money)
money_ts <- ts(money[,2])
money <- read.csv(file = 'volume-of-money-abs-definition-m.csv', stringsAsFactors = F)
money <- money[-nrow(money), ]
money_ts <- ts(money[,2])
money_ts <- ts(money[,2], start = c(1960, 2), frequency = 12)
par9(mfrow = c(3, 1))
par(mfrow = c(3, 1))
money_ts <- ts(money[,2], start = c(1960, 2), frequency = 12)
plot(money_ts)
acf(money_ts)
acf(money_ts)
pacf(money_ts)
money_ts <- ts(as.numeric(money[,2]), start = c(1960, 2), frequency = 12)
par(mfrow = c(3, 1))
plot(money_ts)
acf(money_ts)
pacf(money_ts)
HoltWinters(money_ts, gamma = FALSE)
m <- HoltWinters(money_ts, gamma = FALSE)
plot(m)
17761.5+43.2471
17661.5+43.2471
dev.off()
plot(m)
## HoltWinter for Trend
#set up our transformed data and smoothing parameters data = money.data[,2]
N = length(money_ts)
#initialize level and trend in a very simple way level[1] = money_ts [1]
trend[1] = money_ts[2] - money_ts[1]
## HoltWinter for Trend
# set up our transformed data and smoothing parameters data = money.data[,2]
N <- length(money_ts)
alpha <- 0.7
beta <- 0.5
## prepare empty arrays so we can store values
forecast <- NULL
level <- NULL
trend <- NULL
#initialize level and trend in a very simple way level[1] = money_ts [1]
trend[1] = money_ts[2] - money_ts[1]
for(n in 2:N) {
level[n] <- alpha* money_ts [n] +
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
for(n in 2:N) {
level[n] <- alpha* money_ts [n] + (1-alpha)*(level[n-1]+trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
for(n in 2:N) {
level[n] <- alpha*money_ts[n] + (1-alpha)*(level[n-1]+trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
## prepare empty arrays so we can store values
forecast <- NULL
level <- NULL
trend <- NULL
#initialize level and trend in a very simple way level[1] = money_ts [1]
trend[1] = money_ts[2] - money_ts[1]
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
## HoltWinter for Trend
# set up our transformed data and smoothing parameters data = money.data[,2]
N <- length(money_ts)
alpha <- 0.7
beta <- 0.5
## prepare empty arrays so we can store values
forecast <- NULL
level <- NULL
trend <- NULL
#initialize level and trend in a very simple way level[1] = money_ts [1]
trend[1] <- money_ts[2] - money_ts[1]
for(n in 2:N) {
level[n] <- alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
#initialize level and trend in a very simple way level[1] = money_ts [1]
trend[1] <- money_ts[2] - money_ts[1]
#initialize forecast to get started
forecast[1] <- money_ts[1]
forecast[2] <- money_ts [2]
#loop to build forecasts
for(n in 2:N) {
level[n] <- alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
#  trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
level[n] <- alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
#loop to build forecasts
for(n in 2:N) {
level[n] = alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] = beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
level[n] = alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] = beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
#loop to build forecasts
for(n in 2:N) {
level[n] = alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] = beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
N <- length(money_ts)
alpha <- 0.7
beta <- 0.5
forecast <- NULL
level <- NULL
trend <- NULL
trend[1] <- money_ts[2] - money_ts[1]
forecast[1] <- money_ts[1]
forecast[2] <- money_ts [2]
for(n in 2:N) {
level[n] = alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] = beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
n <- 2
n <- 2
beta*(level[n] - level[n-1])
n <- 2
level[n] <- alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
level
## prepare empty arrays so we can store values
forecast = NULL
level = NULL
trend = NULL
#initialize level and trend in a very simple way level[1] = money_ts [1]
trend[1] <- money_ts[2] - money_ts[1]
#initialize forecast to get started
forecast[1] <- money_ts[1]
forecast[2] <- money_ts [2]
#loop to build forecasts
for(n in 2:N) {
level[n] <- alpha*money_ts[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
## HoltWinter for Trend
# set up our transformed data and smoothing parameters
data = money_ts[,2]
## HoltWinter for Trend
# set up our transformed data and smoothing parameters
data = money[,2]
View(data)
tail(data, 2)
## HoltWinter for Trend
# set up our transformed data and smoothing parameters
data = money[,2]
N <- length(data)
alpha <- 0.7
beta <- 0.5
## prepare empty arrays so we can store values
forecast = NULL
level = NULL
trend = NULL
#initialize level and trend in a very simple way level[1] = data [1]
trend[1] <- data[2] - data[1]
#initialize forecast to get started
forecast[1] <- data[1]
forecast[2] <- data[2]
forecast
trend
level
## prepare empty arrays so we can store values
forecast <- NULL
level <- NULL
trend <- NULL
#initialize level and trend in a very simple way level[1] = data [1]
trend[1] <- data[2] - data[1]
## HoltWinter for Trend
# set up our transformed data and smoothing parameters
data = money[,2]
N <- length(data)
alpha <- 0.7
beta <- 0.5
## prepare empty arrays so we can store values
forecast <- NULL
level <- NULL
trend <- NULL
#initialize level and trend in a very simple way level[1] = data [1]
trend[1] <- data[2] - data[1]
## HoltWinter for Trend
# set up our transformed data and smoothing parameters
data = as.numeric(money[,2])
N <- length(data)
alpha <- 0.7
beta <- 0.5
## prepare empty arrays so we can store values
forecast <- NULL
level <- NULL
trend <- NULL
#initialize level and trend in a very simple way level[1] = data [1]
trend[1] <- data[2] - data[1]
trend
level
forecast
#initialize forecast to get started
forecast[1] <- data[1]
forecast[2] <- data[2]
forecast
for(n in 2:N) {
level[n] <- alpha*data[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
n <- 2
level
level[n] <- alpha*data[n] + (1-alpha)*(level[n-1] + trend[n-1])
levle
level
alpha*data[n] + (1-alpha)*(level[n-1] + trend[n-1])
data[2]
alpha
level
## HoltWinter for Trend
# set up our transformed data and smoothing parameters
data = as.numeric(money[,2])
N <- length(data)
alpha <- 0.7
beta <- 0.5
## prepare empty arrays so we can store values
forecast <- NULL
level <- NULL
trend <- NULL
#initialize level and trend in a very simple way
level[1] <- data [1]
trend[1] <- data[2] - data[1]
#initialize forecast to get started
forecast[1] <- data[1]
forecast[2] <- data[2]
#loop to build forecasts
for(n in 2:N) {
level[n] <- alpha*data[n] + (1-alpha)*(level[n-1] + trend[n-1])
trend[n] <- beta*(level[n] - level[n-1]) + (1-beta)*trend[n-1]
forecast[n+1] <- level[n] + trend[n]
}
forecast[3:N]
m <- HoltWinters(data, alpha = 0.7, beta = 0.5, gamma = FALSE)
plot(m$fitted)
plot(m$fitted)
type(m$fitted)
class(m$fitted)
class(m$fitted[,1])
class(m$fitted[,2])
class(m$fitted[,3])
class(m)
class(m$fitted)
par(mfcol = c(1,2))
plot(forecast[2:N])
plot(m$fitted)
par(mfcol = c(1,2))
plot(forecast[2:N])
plot(m$fitted[,1])
par(mfcol = c(1,2))
plot(forecast[2:N], type = 'l')
plot(m$fitted[,1])
plot(m$fitted[,1], main="Holt Winters Fitting of Money Volume with Bogus Parameters")
par(mfcol = c(1,2))
plot(forecast[2:N], type = 'l', main = "xhat from loop function")
plot(m$fitted[,1], main 'xhat from HolWinters')
par(mfcol = c(1,2))
plot(forecast[2:N], type = 'l', main = "xhat from loop function")
plot(m$fitted[,1], main = 'xhat from HolWinters')
